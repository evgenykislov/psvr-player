#ifndef ROTATION_H
#define ROTATION_H

#include <mutex>

#define GLM_ENABLE_EXPERIMENTAL
#include <glm/gtx/vector_angle.hpp>


class Rotation {
 public:
  Rotation();
  ~Rotation() = default;

  /*! Сбросить координаты к начальному значению: смотрим вперёд горизонтально */
  void Reset();

  /*! Повернуть обзор шлема направо, вверх и самовращение. Поворот задаётся в
  градусах, порядок считается неважным, т.к. приращения угла (должны быть)
  небольшие.
  \param right поворот вправо (-влево) относительно самого шлема
  \param top запрокидывание вверх (-вниз) относительно самого шлема
  \param clock кручение шлема по часовой стрелке (-против часовой) */
  void Rotate(double right, double top, double clock);

  /*! Выдать суммарное (общее) вращение шлема относительно базового расположения
  (смотрим вперёд горизонтально). Умножая эту матрицу на базовый вектор
  получаем вектор текущего направления
  \param rot_mat выдаваемая матрица поворота */
  void GetSummRotation(glm::mat4& rot_mat);

  /*! Установить ускоренное/замедленное вращение: поворот шлема на фиксированный
  угол приводит к кратному увеличению угла. Прим.: поворот набок не ускоряется
  \param rotation_speed ускорение вращения, в штуках. Значение 1.0 - без
  ускорения */
  void SetRotationSpeedup(double speedup);

 private:
  Rotation(const Rotation&) = default;
  Rotation(Rotation&&) = default;
  Rotation& operator=(const Rotation&) = default;
  Rotation& operator=(Rotation&&) = default;

  using vec3d = glm::vec<3, double, glm::defaultp>;

  vec3d view_;  //!< Вектор куда смотрит сам шлем (мировые координаты)
  vec3d tip_;  //!< Вектор куда смотрит верх шлема (мировые координаты)
  double rotation_speedup_;  //!< Коэффициент ускоренного вращения
  std::mutex data_lock_;

  /*! Сосчитаем угол поворота между векторами в заданной плоскости. Поворот
  считается по часовой стрелки с точки зрения вектора нормали. Система
  координат: х - вправо, y - вверх, z - вперёд от нас \param n плоскость, в
  которой считаются углы. Задаётся нормалью \param v1 вектор от которого
  считается поворот \param v2 вектор в сторону которого считается поворот. Если
  вектор нормали очень короткий или вектора v1 или v2параллельный нормали,
  то вычисляется обычный угол между векторами
  (без привязки к плоскости) - и в этом случае он всегда неотрицательный.
  \return угол поворота в радианах (от -pi до +pi) */
  double RadAngle(const vec3d& n, const vec3d& v1, const vec3d& v2);
};

#endif  // ROTATION_H
